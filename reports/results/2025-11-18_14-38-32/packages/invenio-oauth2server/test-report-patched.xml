<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="6" skipped="1" tests="152" time="39.269" timestamp="2025-11-18T13:49:35.877536+00:00" hostname="runnervmg1sw1"><testcase classname="tests.conftest" name="PYDOCSTYLE" time="0.039" /><testcase classname="tests.conftest" name="ISORT" time="0.213" /><testcase classname="tests.conftest" name="black" time="0.429" /><testcase classname="tests.helpers" name="PYDOCSTYLE" time="0.012" /><testcase classname="tests.helpers" name="ISORT" time="0.026" /><testcase classname="tests.helpers" name="black" time="0.186" /><testcase classname="tests.test_admin" name="ISORT" time="0.021" /><testcase classname="tests.test_admin" name="black" time="0.178" /><testcase classname="tests.test_admin" name="test_admin" time="1.009" /><testcase classname="tests.test_alembic" name="ISORT" time="0.011" /><testcase classname="tests.test_alembic" name="black" time="0.163" /><testcase classname="tests.test_alembic" name="test_alembic" time="0.000"><skipped type="pytest.skip" message="Caused by mergepoint">/home/runner/work/invenio-bug-verification/invenio-bug-verification/package-repo/tests/test_alembic.py:16: Caused by mergepoint</skipped></testcase><testcase classname="tests.test_cli" name="ISORT" time="0.015" /><testcase classname="tests.test_cli" name="black" time="0.166" /><testcase classname="tests.test_cli" name="test_cli_tokens" time="0.555" /><testcase classname="tests.test_decorators" name="ISORT" time="0.037" /><testcase classname="tests.test_decorators" name="black" time="0.206" /><testcase classname="tests.test_decorators" name="test_require_api_auth_oauthlib_urldecode_issue" time="0.508" /><testcase classname="tests.test_decorators" name="test_require_api_auth_test1" time="0.591" /><testcase classname="tests.test_decorators" name="test_require_api_auth_test2" time="0.515" /><testcase classname="tests.test_decorators" name="test_require_oauth_scopes_test1" time="0.522" /><testcase classname="tests.test_decorators" name="test_require_oauth_scopes_test2" time="0.530" /><testcase classname="tests.test_decorators" name="test_require_oauth_scopes_allow_anonymous" time="0.529" /><testcase classname="tests.test_decorators" name="test_rest_extension" time="0.519" /><testcase classname="tests.test_decorators" name="test_access_login_required" time="0.579" /><testcase classname="tests.test_decorators" name="test_jwt_client" time="0.674" /><testcase classname="tests.test_invenio_oauth2server" name="ISORT" time="0.021" /><testcase classname="tests.test_invenio_oauth2server" name="black" time="0.172" /><testcase classname="tests.test_invenio_oauth2server" name="test_version" time="0.001" /><testcase classname="tests.test_invenio_oauth2server" name="test_init" time="0.257" /><testcase classname="tests.test_invenio_oauth2server" name="test_init_rest" time="0.004" /><testcase classname="tests.test_invenio_oauth2server" name="test_init_rest_with_oauthlib_monkeypatch" time="0.003" /><testcase classname="tests.test_models" name="ISORT" time="0.053" /><testcase classname="tests.test_models" name="black" time="0.216" /><testcase classname="tests.test_models" name="test_empty_redirect_uri_and_scope" time="0.606" /><testcase classname="tests.test_models" name="test_token_scopes" time="0.525" /><testcase classname="tests.test_models" name="test_registering_invalid_scope" time="0.504" /><testcase classname="tests.test_models" name="test_deletion_of_consumer_resource_owner" time="0.543" /><testcase classname="tests.test_models" name="test_deletion_of_resource_owner_consumer" time="0.542" /><testcase classname="tests.test_models" name="test_deletion_of_client1" time="0.544" /><testcase classname="tests.test_models" name="test_deletion_of_token1" time="0.530" /><testcase classname="tests.test_models" name="test_deletion_of_token2" time="0.534" /><testcase classname="tests.test_provider" name="ISORT" time="0.153" /><testcase classname="tests.test_provider" name="black" time="0.372" /><testcase classname="tests.test_provider" name="test_client_salt" time="0.553" /><testcase classname="tests.test_provider" name="test_invalid_authorize_requests" time="0.682" /><testcase classname="tests.test_provider" name="test_refresh_flow" time="0.772"><failure message="TypeError: can't compare offset-naive and offset-aware datetimes">provider_fixture = &lt;Flask 'testapp'&gt;

    def test_refresh_flow(provider_fixture):
        app = provider_fixture
        with app.test_request_context():
            base_url = "https://{0}".format(app.config["SERVER_NAME"])
            redirect_uri = url_for("oauth2test.authorized", _external=True)
    
            with app.test_client() as client:
                # First login on provider site
                login(client)
    
                data = dict(
                    redirect_uri=redirect_uri,
                    scope="test:scope",
                    response_type="code",
                    client_id="confidential",
                    state="mystate",
                )
    
                r = client.get(url_for("invenio_oauth2server.authorize", **data))
                assert r.status_code == 200
    
                data["confirm"] = "yes"
                data["scope"] = "test:scope"
                data["state"] = "mystate"
    
                # Obtain one time code
                r = client.post(url_for("invenio_oauth2server.authorize"), data=data)
                r.status_code == 302
                next_url, res_data = parse_redirect(r.location)
                assert res_data["code"]
                assert res_data["state"] == ["mystate"]
    
                # Exchange one time code for access token
                r = client.post(
                    url_for("invenio_oauth2server.access_token"),
                    data=dict(
                        client_id="confidential",
                        client_secret="confidential",
                        grant_type="authorization_code",
                        code=res_data["code"],
                    ),
                )
                assert r.status_code == 200
                json_resp = json.loads(r.get_data())
                assert json_resp["access_token"]
                assert json_resp["refresh_token"]
                assert json_resp["scope"] == "test:scope"
                assert json_resp["token_type"] == "Bearer"
                assert json_resp["user"]["id"]
                refresh_token = json_resp["refresh_token"]
                old_access_token = json_resp["access_token"]
    
                # Access token valid
&gt;               r = client.get(
                    url_for("invenio_oauth2server.info", access_token=old_access_token)
                )

tests/test_provider.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/testing.py:235: in open
    response = super().open(
.venv/lib/python3.12/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7fd5820287a0&gt;
token = 'hwbswW6R6aJNiVRnfTA7cKUuJzZfCz', scopes = ('test:scope',)
request = &lt;oauthlib.Request SANITIZED&gt;

    def validate_bearer_token(self, token, scopes, request):
        """Validate access token.
    
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
    
        The validation validates:
    
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
    
        # validate expires
        if tok.expires is not None and \
&gt;               datetime.datetime.now(datetime.timezone.utc) &gt; tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes

.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError</failure></testcase><testcase classname="tests.test_provider" name="test_implicit_flow" time="0.614"><failure message="TypeError: can't compare offset-naive and offset-aware datetimes">provider_fixture = &lt;Flask 'testapp'&gt;

    def test_implicit_flow(provider_fixture):
        app = provider_fixture
        with app.test_request_context():
            redirect_uri = url_for("oauth2test.authorized", _external=True)
    
            with app.test_client() as client:
                # First login on provider site
                login(client)
    
                for client_id in ["dev", "confidential"]:
                    data = dict(
                        redirect_uri=redirect_uri,
                        response_type="token",  # For implicit grant type
                        client_id=client_id,
                        scope="test:scope",
                        state="teststate",
                    )
    
                    # Authorize page
                    r = client.get(
                        url_for("invenio_oauth2server.authorize", **data),
                        follow_redirects=True,
                    )
                    assert r.status_code == 200
    
                    # User confirms request
                    data["confirm"] = "yes"
                    data["scope"] = "test:scope"
                    data["state"] = "teststate"
    
                    r = client.post(url_for("invenio_oauth2server.authorize"), data=data)
                    assert r.status_code == 302
                    # Important - access token exists in URI fragment and must not
                    # be sent to the client.
                    next_url, data = parse_redirect(r.location, parse_fragment=True)
    
                    assert data["access_token"]
                    assert data["token_type"] == ["Bearer"]
                    assert data["state"] == ["teststate"]
                    assert data["scope"] == ["test:scope"]
                    assert data.get("refresh_token") is None
                    assert next_url == redirect_uri
    
                    # Authentication flow has now been completed, and the client
                    # can use the access token to make request to the provider.
&gt;                   r = client.get(
                        url_for(
                            "invenio_oauth2server.info", access_token=data["access_token"]
                        )
                    )

tests/test_provider.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/testing.py:235: in open
    response = super().open(
.venv/lib/python3.12/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7fd5820287a0&gt;
token = 'FL7MeYONrihwTz2gaxif6cQsBrUTXG', scopes = ('test:scope',)
request = &lt;oauthlib.Request SANITIZED&gt;

    def validate_bearer_token(self, token, scopes, request):
        """Validate access token.
    
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
    
        The validation validates:
    
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
    
        # validate expires
        if tok.expires is not None and \
&gt;               datetime.datetime.now(datetime.timezone.utc) &gt; tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes

.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError</failure></testcase><testcase classname="tests.test_provider" name="test_client_flow" time="0.549"><failure message="TypeError: can't compare offset-naive and offset-aware datetimes">provider_fixture = &lt;Flask 'testapp'&gt;

    def test_client_flow(provider_fixture):
        app = provider_fixture
        with app.test_request_context():
            with app.test_client() as client:
                data = dict(
                    client_id="dev",
                    client_secret="dev",  # A public client should NOT do this!
                    grant_type="client_credentials",
                    scope="test:scope",
                )
    
                # Public clients are not allowed to use
                # grant_type=client_credentials
                r = client.post(url_for("invenio_oauth2server.access_token"), data=data)
                assert r.status_code == 401
                assert json.loads(r.get_data()).get("error") == "invalid_client"
    
                data = dict(
                    client_id="confidential",
                    client_secret="confidential",
                    grant_type="client_credentials",
                    scope="test:scope",
                )
    
                # Retrieve access token using client_credentials
                r = client.post(url_for("invenio_oauth2server.access_token"), data=data)
                assert r.status_code == 200
    
                data = json.loads(r.get_data())
                assert data["access_token"]
                assert data["token_type"] == "Bearer"
                assert data["scope"] == "test:scope"
                assert data["user"]["id"]
                assert data.get("refresh_token") is None
    
                # Authentication flow has now been completed, and the client can
                # use the access token to make request to the provider.
&gt;               r = client.get(
                    url_for("invenio_oauth2server.info", access_token=data["access_token"])
                )

tests/test_provider.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/testing.py:235: in open
    response = super().open(
.venv/lib/python3.12/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7fd5820287a0&gt;
token = 'XscMo5HrL0w9VN90opVoSskwnOuu7t', scopes = ('test:scope',)
request = &lt;oauthlib.Request SANITIZED&gt;

    def validate_bearer_token(self, token, scopes, request):
        """Validate access token.
    
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
    
        The validation validates:
    
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
    
        # validate expires
        if tok.expires is not None and \
&gt;               datetime.datetime.now(datetime.timezone.utc) &gt; tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes

.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError</failure></testcase><testcase classname="tests.test_provider" name="test_auth_flow_denied" time="0.600" /><testcase classname="tests.test_provider" name="test_personal_access_token" time="0.536" /><testcase classname="tests.test_provider" name="test_resource_auth_methods" time="0.535" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[q=RegularArg-True]" time="0.476" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[a=1&amp;b=2&amp;c=3-True]" time="0.476" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[q=text+with+spaces-True]" time="0.590" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[q=title:TheTitle-True]" time="0.478" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[q=properly%20encoded%24-True]" time="0.480" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[$type=search-False]" time="0.473" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[q=Joan+D'Arc-False]" time="0.495" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[with regular spaces-False]" time="0.475" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[json_data={a: 42}-False]" time="0.483" /><testcase classname="tests.test_provider" name="test_oauthlib_urldecoding_issue[array=[1, 2, 3]-False]" time="0.478" /><testcase classname="tests.test_provider" name="test_oauthlib_monkeypatch" time="0.475" /><testcase classname="tests.test_provider" name="test_settings_index" time="0.690" /><testcase classname="tests.test_provider" name="test_info_not_accessible_in_production" time="0.561"><failure message="assert 500 == 404&#10; +  where 500 = &lt;WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]&gt;.status_code">provider_fixture = &lt;Flask 'testapp'&gt;

    def test_info_not_accessible_in_production(provider_fixture):
        """Info route should not be available in production mode."""
        app = provider_fixture
        with app.test_request_context():
            with app.test_client() as client:
                app.config.update(
                    DEBUG=False,
                    TESTING=False,
                )
                data = dict(
                    client_id="dev",
                    client_secret="dev",  # A public client should NOT do this!
                    grant_type="client_credentials",
                    scope="test:scope",
                )
    
                # Public clients are not allowed to use
                # grant_type=client_credentials
                r = client.post(url_for("invenio_oauth2server.access_token"), data=data)
                assert r.status_code == 401
                assert json.loads(r.get_data()).get("error") == "invalid_client"
    
                data = dict(
                    client_id="confidential",
                    client_secret="confidential",
                    grant_type="client_credentials",
                    scope="test:scope",
                )
    
                # Retrieve access token using client_credentials
                r = client.post(url_for("invenio_oauth2server.access_token"), data=data)
                assert r.status_code == 200
    
                data = json.loads(r.get_data())
                assert data["access_token"]
                assert data["token_type"] == "Bearer"
                assert data["scope"] == "test:scope"
                assert data.get("refresh_token") is None
                assert data["user"]["id"]
    
                # Authentication flow has now been completed, and the client can
                # use the access token to make request to the provider.
                r = client.get(
                    url_for("invenio_oauth2server.info", access_token=data["access_token"])
                )
&gt;               assert r.status_code == 404
E               assert 500 == 404
E                +  where 500 = &lt;WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]&gt;.status_code

tests/test_provider.py:739: AssertionError</failure></testcase><testcase classname="tests.test_provider" name="test_expired_refresh_flow" time="0.642"><failure message="TypeError: can't compare offset-naive and offset-aware datetimes">provider_fixture = &lt;Flask 'testapp'&gt;

    def test_expired_refresh_flow(provider_fixture):
        """Test refresh flow with an expired token."""
        app = provider_fixture
        # First login on provider site
        with app.test_request_context():
            with app.test_client() as client:
                login(client)
    
                data = dict(
                    redirect_uri=url_for("oauth2test.authorized", _external=True),
                    scope="test:scope",
                    response_type="code",
                    client_id="confidential",
                    state="mystate",
                )
    
                r = client.get(url_for("invenio_oauth2server.authorize", **data))
                assert r.status_code == 200
    
                data["confirm"] = "yes"
                data["scope"] = "test:scope"
                data["state"] = "mystate"
    
                # Obtain one time code
                r = client.post(url_for("invenio_oauth2server.authorize"), data=data)
                assert r.status_code == 302
                next_url, res_data = parse_redirect(r.location)
                assert res_data["code"]
                assert res_data["state"] == ["mystate"]
    
                # Exchange one time code for access token
                r = client.post(
                    url_for("invenio_oauth2server.access_token"),
                    data=dict(
                        client_id="confidential",
                        client_secret="confidential",
                        grant_type="authorization_code",
                        code=res_data["code"],
                    ),
                )
                assert r.status_code == 200
                assert json.loads(r.get_data())["access_token"]
                assert json.loads(r.get_data())["refresh_token"]
                assert json.loads(r.get_data())["expires_in"] &gt; 0
                assert json.loads(r.get_data())["scope"] == "test:scope"
                assert json.loads(r.get_data())["token_type"] == "Bearer"
                assert json.loads(r.get_data())["user"]["id"]
                refresh_token = json.loads(r.get_data())["refresh_token"]
                old_access_token = json.loads(r.get_data())["access_token"]
    
                # Access token valid
&gt;               r = client.get(
                    url_for("invenio_oauth2server.info", access_token=old_access_token)
                )

tests/test_provider.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/testing.py:235: in open
    response = super().open(
.venv/lib/python3.12/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7fd5820287a0&gt;
token = 'iAgBTHY4RkG7Y7sv7sQe7hOt6Zshfe', scopes = ('test:scope',)
request = &lt;oauthlib.Request SANITIZED&gt;

    def validate_bearer_token(self, token, scopes, request):
        """Validate access token.
    
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
    
        The validation validates:
    
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
    
        # validate expires
        if tok.expires is not None and \
&gt;               datetime.datetime.now(datetime.timezone.utc) &gt; tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes

.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError</failure></testcase><testcase classname="tests.test_provider" name="test_not_allowed_public_refresh_flow" time="0.636"><failure message="TypeError: can't compare offset-naive and offset-aware datetimes">provider_fixture = &lt;Flask 'testapp'&gt;

    def test_not_allowed_public_refresh_flow(provider_fixture):
        """Public token should not allow refreshing."""
        app = provider_fixture
        # First login on provider site
        with app.test_request_context():
            with app.test_client() as client:
                login(client)
    
                data = dict(
                    redirect_uri=url_for("oauth2test.authorized", _external=True),
                    scope="test:scope",
                    response_type="code",
                    client_id="dev",
                    state="mystate",
                )
    
                r = client.get(url_for("invenio_oauth2server.authorize", **data))
                assert r.status_code == 200
    
                data["confirm"] = "yes"
                data["scope"] = "test:scope"
                data["state"] = "mystate"
    
                # Obtain one time code
                r = client.post(url_for("invenio_oauth2server.authorize"), data=data)
                assert r.status_code == 302
                next_url, res_data = parse_redirect(r.location)
                assert res_data["code"]
                assert res_data["state"] == ["mystate"]
    
                # Exchange one time code for access token
                r = client.post(
                    url_for("invenio_oauth2server.access_token"),
                    data=dict(
                        client_id="dev",
                        client_secret="dev",
                        grant_type="authorization_code",
                        code=res_data["code"],
                    ),
                )
                assert r.status_code == 200
                json_resp = json.loads(r.get_data())
                assert json_resp["access_token"]
                assert json_resp["refresh_token"]
                assert json_resp["expires_in"] &gt; 0
                assert json_resp["scope"] == "test:scope"
                assert json_resp["token_type"] == "Bearer"
                assert json_resp["user"]["id"]
                refresh_token = json_resp["refresh_token"]
                old_access_token = json_resp["access_token"]
    
                # Access token valid
&gt;               r = client.get(
                    url_for("invenio_oauth2server.info", access_token=old_access_token)
                )

tests/test_provider.py:897: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.12/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/testing.py:235: in open
    response = super().open(
.venv/lib/python3.12/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.12/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7fd5820287a0&gt;
token = 'tLcowsvqtHmwRtcxS8Id4SV2paK1aH', scopes = ('test:scope',)
request = &lt;oauthlib.Request SANITIZED&gt;

    def validate_bearer_token(self, token, scopes, request):
        """Validate access token.
    
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
    
        The validation validates:
    
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
    
        # validate expires
        if tok.expires is not None and \
&gt;               datetime.datetime.now(datetime.timezone.utc) &gt; tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes

.venv/lib/python3.12/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError</failure></testcase><testcase classname="tests.test_provider" name="test_password_grant_type" time="0.714" /><testcase classname="tests.test_provider" name="test_email_scope" time="0.554" /><testcase classname="tests.test_server" name="ISORT" time="0.009" /><testcase classname="tests.test_server" name="black" time="0.161" /><testcase classname="tests.test_server" name="test_user_identity_init" time="0.542" /><testcase classname="tests.test_settings" name="ISORT" time="0.038" /><testcase classname="tests.test_settings" name="black" time="0.204" /><testcase classname="tests.test_settings" name="test_personal_token_management" time="0.672" /><testcase classname="tests.test_settings" name="test_authorized_app_revocation" time="0.648" /><testcase classname="tests.test_settings" name="test_client_management" time="0.699" /><testcase classname="tests.test_utils" name="ISORT" time="0.015" /><testcase classname="tests.test_utils" name="black" time="0.167" /><testcase classname="tests.test_utils" name="test_rebuilding_access_tokens" time="0.551" /><testcase classname="tests.test_validators" name="ISORT" time="0.016" /><testcase classname="tests.test_validators" name="black" time="0.172" /><testcase classname="tests.test_validators" name="test_validate_redirect_uri[example.org/-expected0]" time="0.001" /><testcase classname="tests.test_validators" name="test_validate_redirect_uri[http://-expected1]" time="0.001" /><testcase classname="tests.test_validators" name="test_validate_redirect_uri[http://example.org/-expected2]" time="0.001" /><testcase classname="tests.test_validators" name="test_validate_redirect_uri[https://example.org/-None]" time="0.001" /><testcase classname="tests.test_validators" name="test_validate_redirect_uri[https://localhost/-None]" time="0.001" /><testcase classname="tests.test_validators" name="test_validate_redirect_uri[https://127.0.0.1-None]" time="0.001" /><testcase classname="tests.test_validators" name="test_url_validator" time="0.480" /><testcase classname="invenio_oauth2server.__init__" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_oauth2server.__init__" name="ISORT" time="0.016" /><testcase classname="invenio_oauth2server.__init__" name="black" time="0.167" /><testcase classname="invenio_oauth2server.admin" name="PYDOCSTYLE" time="0.006" /><testcase classname="invenio_oauth2server.admin" name="ISORT" time="0.019" /><testcase classname="invenio_oauth2server.admin" name="black" time="0.169" /><testcase classname="invenio_oauth2server.alembic.12a88921ada2_create_oauth2server_tables" name="PYDOCSTYLE" time="0.010" /><testcase classname="invenio_oauth2server.alembic.12a88921ada2_create_oauth2server_tables" name="ISORT" time="0.022" /><testcase classname="invenio_oauth2server.alembic.12a88921ada2_create_oauth2server_tables" name="black" time="0.181" /><testcase classname="invenio_oauth2server.alembic.4e57407b8e4a_add_on_delete_cascade" name="PYDOCSTYLE" time="0.008" /><testcase classname="invenio_oauth2server.alembic.4e57407b8e4a_add_on_delete_cascade" name="ISORT" time="0.025" /><testcase classname="invenio_oauth2server.alembic.4e57407b8e4a_add_on_delete_cascade" name="black" time="0.180" /><testcase classname="invenio_oauth2server.alembic.aa546f2a8d2f_create_oauth2server_branch" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_oauth2server.alembic.aa546f2a8d2f_create_oauth2server_branch" name="ISORT" time="0.006" /><testcase classname="invenio_oauth2server.alembic.aa546f2a8d2f_create_oauth2server_branch" name="black" time="0.162" /><testcase classname="invenio_oauth2server.cli" name="PYDOCSTYLE" time="0.013" /><testcase classname="invenio_oauth2server.cli" name="ISORT" time="0.023" /><testcase classname="invenio_oauth2server.cli" name="black" time="0.181" /><testcase classname="invenio_oauth2server.config" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_oauth2server.config" name="ISORT" time="0.012" /><testcase classname="invenio_oauth2server.config" name="black" time="0.167" /><testcase classname="invenio_oauth2server.decorators" name="PYDOCSTYLE" time="0.008" /><testcase classname="invenio_oauth2server.decorators" name="ISORT" time="0.016" /><testcase classname="invenio_oauth2server.decorators" name="black" time="0.174" /><testcase classname="invenio_oauth2server.errors" name="PYDOCSTYLE" time="0.010" /><testcase classname="invenio_oauth2server.errors" name="ISORT" time="0.018" /><testcase classname="invenio_oauth2server.errors" name="black" time="0.175" /><testcase classname="invenio_oauth2server.ext" name="PYDOCSTYLE" time="0.030" /><testcase classname="invenio_oauth2server.ext" name="ISORT" time="0.059" /><testcase classname="invenio_oauth2server.ext" name="black" time="0.214" /><testcase classname="invenio_oauth2server.forms" name="PYDOCSTYLE" time="0.014" /><testcase classname="invenio_oauth2server.forms" name="ISORT" time="0.038" /><testcase classname="invenio_oauth2server.forms" name="black" time="0.194" /><testcase classname="invenio_oauth2server.models" name="PYDOCSTYLE" time="0.034" /><testcase classname="invenio_oauth2server.models" name="ISORT" time="0.072" /><testcase classname="invenio_oauth2server.models" name="black" time="0.228" /><testcase classname="invenio_oauth2server.provider" name="PYDOCSTYLE" time="0.013" /><testcase classname="invenio_oauth2server.provider" name="ISORT" time="0.031" /><testcase classname="invenio_oauth2server.provider" name="black" time="0.184" /><testcase classname="invenio_oauth2server.proxies" name="PYDOCSTYLE" time="0.002" /><testcase classname="invenio_oauth2server.proxies" name="ISORT" time="0.008" /><testcase classname="invenio_oauth2server.proxies" name="black" time="0.163" /><testcase classname="invenio_oauth2server.scopes" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_oauth2server.scopes" name="ISORT" time="0.009" /><testcase classname="invenio_oauth2server.scopes" name="black" time="0.163" /><testcase classname="invenio_oauth2server.theme.semantic.form_styling" name="PYDOCSTYLE" time="0.005" /><testcase classname="invenio_oauth2server.theme.semantic.form_styling" name="ISORT" time="0.012" /><testcase classname="invenio_oauth2server.theme.semantic.form_styling" name="black" time="0.169" /><testcase classname="invenio_oauth2server.utils" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_oauth2server.utils" name="ISORT" time="0.018" /><testcase classname="invenio_oauth2server.utils" name="black" time="0.169" /><testcase classname="invenio_oauth2server.validators" name="PYDOCSTYLE" time="0.007" /><testcase classname="invenio_oauth2server.validators" name="ISORT" time="0.015" /><testcase classname="invenio_oauth2server.validators" name="black" time="0.174" /><testcase classname="invenio_oauth2server.views.__init__" name="PYDOCSTYLE" time="0.003" /><testcase classname="invenio_oauth2server.views.__init__" name="ISORT" time="0.007" /><testcase classname="invenio_oauth2server.views.__init__" name="black" time="0.160" /><testcase classname="invenio_oauth2server.views.server" name="PYDOCSTYLE" time="0.013" /><testcase classname="invenio_oauth2server.views.server" name="ISORT" time="0.029" /><testcase classname="invenio_oauth2server.views.server" name="black" time="0.186" /><testcase classname="invenio_oauth2server.views.settings" name="PYDOCSTYLE" time="0.022" /><testcase classname="invenio_oauth2server.views.settings" name="ISORT" time="0.045" /><testcase classname="invenio_oauth2server.views.settings" name="black" time="0.209" /></testsuite></testsuites>